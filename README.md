# Advent of Code 2023 - Rust

Mostly a learning experience for Rust: solutions will be pretty hacky and non-idiomatic. But I might revisit and try to optimise later on (e.g. using threads or proper error handling).

Day 4 Update: This is getting to be a little more time consuming than I expected, so I will be doing catch up on future days/parts if they are taking too long. It seems that the difficulty this year is maybe harder than people expect from the first few days and, when combined with doing this while learning Rust, I am going to be ok with doing puzzles a few days late, when I have a little more time.

### Notes
- Day 2: Parsing was a nightmare. The logic I came up with fine, but fought with the compiler for a long time to get the outputs I needed. Had to google how to get the regex into a vector for each color (the whole filter_map() and flatten()). I'll go back and try to figure out why my approach didn't work: was getting all kinds of Results and Options and Regex types that I couldn't operate on.
  - Part 2 was pretty easy after copying the code. But I think there could be some much better refactoring of the logic. I should have parsed the line in a function, and checked if possible separately.
- Day 3: The 2d array search is interesting. I ended up using the same logic yesterday to walk through the line and parse numbers from the individual digits.
  - Had to find a method online to come up with a creative way to ID which gears are validly associated with parts. Solution was to find any gear near a part and use the coordinates of that gear in a HashMap. Then can look for any gear that has 2 parts associated with it.
- Day 4: Could make things a lot more concise by splitting the string, but I wanted to play about a little with the parsing logic (moving bounds looking for digits and :| symbols). I think the set intersection method is the best way I can think of to find the matching elements: it takes one pass to build the sets and then lookups are quick.
  - Part 2 was pretty confusing, but the logic worked. Spent a long time fighting the compiler with the HashMap and updating values.
- Day 5: A difficult file to parse, I found. Took a lot of searching to find the correct methods to use for splitting on whitespace since, unlike Python, the split method is returning an iterator and can't just be called by indices on an array. I think it took longer than it should have to do the parsing: after I had that I found it pretty simple to write the loop to move through the maps. I did have some issues by forgetting to use a named continue to get out of the innermost loop. The named loops are useful for control flow, though.
  - Part 2 was a brute force through all possible values from the seed ranges. I did not use any logic to check if we are looking at any value more than once (due to overlapping ranges). The only "optimisation" I introduced was to replace the vector of locations (on which I called min() in part 1) with a lowest_location u64, against which I checked every location as it was calculated. I did this to avoid storing a vector of all possible locations.
  - I will come back to this one and refactor to a more efficient algorithm for part 2.
- Day 6: First time I have done the puzzle after midnight. It was an easy logic to brute force. There is a root-finding method based on where the distance function $distance = (time - hold) * hold$ is greater than the record from a functional perspective, but too tired for that. Will try to do that tomorrow. After a few days of working with Rust, the line parsing was pretty easy. Just used some splits and skip() methods to get the numbers, and zipped them together.
  - Part 2 was not too bad. Just a case of figuring out how to strip the space between the numbers. Collecting to a string after split_whitespace() and then parsing to a u64 worked fine. Maybe there's a better way? Again, the brute force was all for tonight.
  - Changed logic to use quadratic equation: still need to handle edge cases where roots are on the int, I think. Need to think more about the floor/ceil logic there.
- Day 7: Logic was straightforward, although I applied sort_by_key in the wrong order at first. Actually coding it up was a real pain, and I need to refactor the whole thing! The muli-layered sort at the end is one of the ugliest things I've ever seen.
  - Part 2 was ok, again just a little awkward to code in Rust.